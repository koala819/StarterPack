"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nextui-org+react-rsc-utils@2.0.10";
exports.ids = ["vendor-chunks/@nextui-org+react-rsc-utils@2.0.10"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-2GZPFWUB.mjs":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-2GZPFWUB.mjs ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   require_react: () => (/* binding */ require_react)\n/* harmony export */ });\n/* harmony import */ var _chunk_UYSIEMEK_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-UYSIEMEK.mjs */ \"(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-UYSIEMEK.mjs\");\n\n\n// ../../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js\nvar require_react_production_min = (0,_chunk_UYSIEMEK_mjs__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({\n  \"../../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.production.min.js\"(exports) {\n    \"use strict\";\n    var l = Symbol.for(\"react.element\");\n    var n = Symbol.for(\"react.portal\");\n    var p = Symbol.for(\"react.fragment\");\n    var q = Symbol.for(\"react.strict_mode\");\n    var r = Symbol.for(\"react.profiler\");\n    var t = Symbol.for(\"react.provider\");\n    var u = Symbol.for(\"react.context\");\n    var v = Symbol.for(\"react.forward_ref\");\n    var w = Symbol.for(\"react.suspense\");\n    var x = Symbol.for(\"react.memo\");\n    var y = Symbol.for(\"react.lazy\");\n    var z = Symbol.iterator;\n    function A(a) {\n      if (null === a || \"object\" !== typeof a)\n        return null;\n      a = z && a[z] || a[\"@@iterator\"];\n      return \"function\" === typeof a ? a : null;\n    }\n    var B = { isMounted: function() {\n      return false;\n    }, enqueueForceUpdate: function() {\n    }, enqueueReplaceState: function() {\n    }, enqueueSetState: function() {\n    } };\n    var C = Object.assign;\n    var D = {};\n    function E(a, b, e) {\n      this.props = a;\n      this.context = b;\n      this.refs = D;\n      this.updater = e || B;\n    }\n    E.prototype.isReactComponent = {};\n    E.prototype.setState = function(a, b) {\n      if (\"object\" !== typeof a && \"function\" !== typeof a && null != a)\n        throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n      this.updater.enqueueSetState(this, a, b, \"setState\");\n    };\n    E.prototype.forceUpdate = function(a) {\n      this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n    };\n    function F() {\n    }\n    F.prototype = E.prototype;\n    function G(a, b, e) {\n      this.props = a;\n      this.context = b;\n      this.refs = D;\n      this.updater = e || B;\n    }\n    var H = G.prototype = new F();\n    H.constructor = G;\n    C(H, E.prototype);\n    H.isPureReactComponent = true;\n    var I = Array.isArray;\n    var J = Object.prototype.hasOwnProperty;\n    var K = { current: null };\n    var L = { key: true, ref: true, __self: true, __source: true };\n    function M(a, b, e) {\n      var d, c = {}, k = null, h = null;\n      if (null != b)\n        for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = \"\" + b.key), b)\n          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);\n      var g = arguments.length - 2;\n      if (1 === g)\n        c.children = e;\n      else if (1 < g) {\n        for (var f = Array(g), m = 0; m < g; m++)\n          f[m] = arguments[m + 2];\n        c.children = f;\n      }\n      if (a && a.defaultProps)\n        for (d in g = a.defaultProps, g)\n          void 0 === c[d] && (c[d] = g[d]);\n      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };\n    }\n    function N(a, b) {\n      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };\n    }\n    function O(a) {\n      return \"object\" === typeof a && null !== a && a.$$typeof === l;\n    }\n    function escape(a) {\n      var b = { \"=\": \"=0\", \":\": \"=2\" };\n      return \"$\" + a.replace(/[=:]/g, function(a2) {\n        return b[a2];\n      });\n    }\n    var P = /\\/+/g;\n    function Q(a, b) {\n      return \"object\" === typeof a && null !== a && null != a.key ? escape(\"\" + a.key) : b.toString(36);\n    }\n    function R(a, b, e, d, c) {\n      var k = typeof a;\n      if (\"undefined\" === k || \"boolean\" === k)\n        a = null;\n      var h = false;\n      if (null === a)\n        h = true;\n      else\n        switch (k) {\n          case \"string\":\n          case \"number\":\n            h = true;\n            break;\n          case \"object\":\n            switch (a.$$typeof) {\n              case l:\n              case n:\n                h = true;\n            }\n        }\n      if (h)\n        return h = a, c = c(h), a = \"\" === d ? \".\" + Q(h, 0) : d, I(c) ? (e = \"\", null != a && (e = a.replace(P, \"$&/\") + \"/\"), R(c, b, e, \"\", function(a2) {\n          return a2;\n        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? \"\" : (\"\" + c.key).replace(P, \"$&/\") + \"/\") + a)), b.push(c)), 1;\n      h = 0;\n      d = \"\" === d ? \".\" : d + \":\";\n      if (I(a))\n        for (var g = 0; g < a.length; g++) {\n          k = a[g];\n          var f = d + Q(k, g);\n          h += R(k, b, e, f, c);\n        }\n      else if (f = A(a), \"function\" === typeof f)\n        for (a = f.call(a), g = 0; !(k = a.next()).done; )\n          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);\n      else if (\"object\" === k)\n        throw b = String(a), Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === b ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : b) + \"). If you meant to render a collection of children, use an array instead.\");\n      return h;\n    }\n    function S(a, b, e) {\n      if (null == a)\n        return a;\n      var d = [], c = 0;\n      R(a, d, \"\", \"\", function(a2) {\n        return b.call(e, a2, c++);\n      });\n      return d;\n    }\n    function T(a) {\n      if (-1 === a._status) {\n        var b = a._result;\n        b = b();\n        b.then(function(b2) {\n          if (0 === a._status || -1 === a._status)\n            a._status = 1, a._result = b2;\n        }, function(b2) {\n          if (0 === a._status || -1 === a._status)\n            a._status = 2, a._result = b2;\n        });\n        -1 === a._status && (a._status = 0, a._result = b);\n      }\n      if (1 === a._status)\n        return a._result.default;\n      throw a._result;\n    }\n    var U = { current: null };\n    var V = { transition: null };\n    var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };\n    exports.Children = { map: S, forEach: function(a, b, e) {\n      S(a, function() {\n        b.apply(this, arguments);\n      }, e);\n    }, count: function(a) {\n      var b = 0;\n      S(a, function() {\n        b++;\n      });\n      return b;\n    }, toArray: function(a) {\n      return S(a, function(a2) {\n        return a2;\n      }) || [];\n    }, only: function(a) {\n      if (!O(a))\n        throw Error(\"React.Children.only expected to receive a single React element child.\");\n      return a;\n    } };\n    exports.Component = E;\n    exports.Fragment = p;\n    exports.Profiler = r;\n    exports.PureComponent = G;\n    exports.StrictMode = q;\n    exports.Suspense = w;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;\n    exports.cloneElement = function(a, b, e) {\n      if (null === a || void 0 === a)\n        throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + a + \".\");\n      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;\n      if (null != b) {\n        void 0 !== b.ref && (k = b.ref, h = K.current);\n        void 0 !== b.key && (c = \"\" + b.key);\n        if (a.type && a.type.defaultProps)\n          var g = a.type.defaultProps;\n        for (f in b)\n          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);\n      }\n      var f = arguments.length - 2;\n      if (1 === f)\n        d.children = e;\n      else if (1 < f) {\n        g = Array(f);\n        for (var m = 0; m < f; m++)\n          g[m] = arguments[m + 2];\n        d.children = g;\n      }\n      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };\n    };\n    exports.createContext = function(a) {\n      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };\n      a.Provider = { $$typeof: t, _context: a };\n      return a.Consumer = a;\n    };\n    exports.createElement = M;\n    exports.createFactory = function(a) {\n      var b = M.bind(null, a);\n      b.type = a;\n      return b;\n    };\n    exports.createRef = function() {\n      return { current: null };\n    };\n    exports.forwardRef = function(a) {\n      return { $$typeof: v, render: a };\n    };\n    exports.isValidElement = O;\n    exports.lazy = function(a) {\n      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };\n    };\n    exports.memo = function(a, b) {\n      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };\n    };\n    exports.startTransition = function(a) {\n      var b = V.transition;\n      V.transition = {};\n      try {\n        a();\n      } finally {\n        V.transition = b;\n      }\n    };\n    exports.unstable_act = function() {\n      throw Error(\"act(...) is not supported in production builds of React.\");\n    };\n    exports.useCallback = function(a, b) {\n      return U.current.useCallback(a, b);\n    };\n    exports.useContext = function(a) {\n      return U.current.useContext(a);\n    };\n    exports.useDebugValue = function() {\n    };\n    exports.useDeferredValue = function(a) {\n      return U.current.useDeferredValue(a);\n    };\n    exports.useEffect = function(a, b) {\n      return U.current.useEffect(a, b);\n    };\n    exports.useId = function() {\n      return U.current.useId();\n    };\n    exports.useImperativeHandle = function(a, b, e) {\n      return U.current.useImperativeHandle(a, b, e);\n    };\n    exports.useInsertionEffect = function(a, b) {\n      return U.current.useInsertionEffect(a, b);\n    };\n    exports.useLayoutEffect = function(a, b) {\n      return U.current.useLayoutEffect(a, b);\n    };\n    exports.useMemo = function(a, b) {\n      return U.current.useMemo(a, b);\n    };\n    exports.useReducer = function(a, b, e) {\n      return U.current.useReducer(a, b, e);\n    };\n    exports.useRef = function(a) {\n      return U.current.useRef(a);\n    };\n    exports.useState = function(a) {\n      return U.current.useState(a);\n    };\n    exports.useSyncExternalStore = function(a, b, e) {\n      return U.current.useSyncExternalStore(a, b, e);\n    };\n    exports.useTransition = function() {\n      return U.current.useTransition();\n    };\n    exports.version = \"18.2.0\";\n  }\n});\n\n// ../../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js\nvar require_react_development = (0,_chunk_UYSIEMEK_mjs__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({\n  \"../../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js\"(exports, module) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var ReactVersion = \"18.2.0\";\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var ReactCurrentDispatcher = {\n          current: null\n        };\n        var ReactCurrentBatchConfig = {\n          transition: null\n        };\n        var ReactCurrentActQueue = {\n          current: null,\n          isBatchingLegacy: false,\n          didScheduleLegacyUpdate: false\n        };\n        var ReactCurrentOwner = {\n          current: null\n        };\n        var ReactDebugCurrentFrame = {};\n        var currentExtraStackFrame = null;\n        function setExtraStackFrame(stack) {\n          {\n            currentExtraStackFrame = stack;\n          }\n        }\n        {\n          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {\n            {\n              currentExtraStackFrame = stack;\n            }\n          };\n          ReactDebugCurrentFrame.getCurrentStack = null;\n          ReactDebugCurrentFrame.getStackAddendum = function() {\n            var stack = \"\";\n            if (currentExtraStackFrame) {\n              stack += currentExtraStackFrame;\n            }\n            var impl = ReactDebugCurrentFrame.getCurrentStack;\n            if (impl) {\n              stack += impl() || \"\";\n            }\n            return stack;\n          };\n        }\n        var enableScopeAPI = false;\n        var enableCacheElement = false;\n        var enableTransitionTracing = false;\n        var enableLegacyHidden = false;\n        var enableDebugTracing = false;\n        var ReactSharedInternals = {\n          ReactCurrentDispatcher,\n          ReactCurrentBatchConfig,\n          ReactCurrentOwner\n        };\n        {\n          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n        }\n        function warn(format) {\n          {\n            {\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n              printWarning(\"warn\", format, args);\n            }\n          }\n        }\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var didWarnStateUpdateForUnmountedComponent = {};\n        function warnNoop(publicInstance, callerName) {\n          {\n            var _constructor = publicInstance.constructor;\n            var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n            var warningKey = componentName + \".\" + callerName;\n            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n              return;\n            }\n            error(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", callerName, componentName);\n            didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n          }\n        }\n        var ReactNoopUpdateQueue = {\n          isMounted: function(publicInstance) {\n            return false;\n          },\n          enqueueForceUpdate: function(publicInstance, callback, callerName) {\n            warnNoop(publicInstance, \"forceUpdate\");\n          },\n          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n            warnNoop(publicInstance, \"replaceState\");\n          },\n          enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n            warnNoop(publicInstance, \"setState\");\n          }\n        };\n        var assign = Object.assign;\n        var emptyObject = {};\n        {\n          Object.freeze(emptyObject);\n        }\n        function Component(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject;\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n        Component.prototype.isReactComponent = {};\n        Component.prototype.setState = function(partialState, callback) {\n          if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n            throw new Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n          }\n          this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n        };\n        Component.prototype.forceUpdate = function(callback) {\n          this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n        };\n        {\n          var deprecatedAPIs = {\n            isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\n            replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\n          };\n          var defineDeprecationWarning = function(methodName, info) {\n            Object.defineProperty(Component.prototype, methodName, {\n              get: function() {\n                warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                return void 0;\n              }\n            });\n          };\n          for (var fnName in deprecatedAPIs) {\n            if (deprecatedAPIs.hasOwnProperty(fnName)) {\n              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n            }\n          }\n        }\n        function ComponentDummy() {\n        }\n        ComponentDummy.prototype = Component.prototype;\n        function PureComponent(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject;\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n        pureComponentPrototype.constructor = PureComponent;\n        assign(pureComponentPrototype, Component.prototype);\n        pureComponentPrototype.isPureReactComponent = true;\n        function createRef() {\n          var refObject = {\n            current: null\n          };\n          {\n            Object.seal(refObject);\n          }\n          return refObject;\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n        {\n          didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n          {\n            if (hasOwnProperty.call(config, \"ref\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.ref !== void 0;\n        }\n        function hasValidKey(config) {\n          {\n            if (hasOwnProperty.call(config, \"key\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.key !== void 0;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n          var warnAboutAccessingKey = function() {\n            {\n              if (!specialPropKeyWarningShown) {\n                specialPropKeyWarningShown = true;\n                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            }\n          };\n          warnAboutAccessingKey.isReactWarning = true;\n          Object.defineProperty(props, \"key\", {\n            get: warnAboutAccessingKey,\n            configurable: true\n          });\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n          var warnAboutAccessingRef = function() {\n            {\n              if (!specialPropRefWarningShown) {\n                specialPropRefWarningShown = true;\n                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            }\n          };\n          warnAboutAccessingRef.isReactWarning = true;\n          Object.defineProperty(props, \"ref\", {\n            get: warnAboutAccessingRef,\n            configurable: true\n          });\n        }\n        function warnIfStringRefCannotBeAutoConverted(config) {\n          {\n            if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n              if (!didWarnAboutStringRefs[componentName]) {\n                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n        }\n        var ReactElement = function(type, key, ref, self, source, owner, props) {\n          var element = {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type,\n            key,\n            ref,\n            props,\n            _owner: owner\n          };\n          {\n            element._store = {};\n            Object.defineProperty(element._store, \"validated\", {\n              configurable: false,\n              enumerable: false,\n              writable: true,\n              value: false\n            });\n            Object.defineProperty(element, \"_self\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: self\n            });\n            Object.defineProperty(element, \"_source\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: source\n            });\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n          return element;\n        };\n        function createElement(type, config, children) {\n          var propName;\n          var props = {};\n          var key = null;\n          var ref = null;\n          var self = null;\n          var source = null;\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              {\n                warnIfStringRefCannotBeAutoConverted(config);\n              }\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            self = config.__self === void 0 ? null : config.__self;\n            source = config.__source === void 0 ? null : config.__source;\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n          }\n          var childrenLength = arguments.length - 2;\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n            {\n              if (Object.freeze) {\n                Object.freeze(childArray);\n              }\n            }\n            props.children = childArray;\n          }\n          if (type && type.defaultProps) {\n            var defaultProps = type.defaultProps;\n            for (propName in defaultProps) {\n              if (props[propName] === void 0) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n          }\n          {\n            if (key || ref) {\n              var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n              if (key) {\n                defineKeyPropWarningGetter(props, displayName);\n              }\n              if (ref) {\n                defineRefPropWarningGetter(props, displayName);\n              }\n            }\n          }\n          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n        function cloneAndReplaceKey(oldElement, newKey) {\n          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n          return newElement;\n        }\n        function cloneElement(element, config, children) {\n          if (element === null || element === void 0) {\n            throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n          }\n          var propName;\n          var props = assign({}, element.props);\n          var key = element.key;\n          var ref = element.ref;\n          var self = element._self;\n          var source = element._source;\n          var owner = element._owner;\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              owner = ReactCurrentOwner.current;\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            var defaultProps;\n            if (element.type && element.type.defaultProps) {\n              defaultProps = element.type.defaultProps;\n            }\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                if (config[propName] === void 0 && defaultProps !== void 0) {\n                  props[propName] = defaultProps[propName];\n                } else {\n                  props[propName] = config[propName];\n                }\n              }\n            }\n          }\n          var childrenLength = arguments.length - 2;\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n            props.children = childArray;\n          }\n          return ReactElement(element.type, key, ref, self, source, owner, props);\n        }\n        function isValidElement(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        var SEPARATOR = \".\";\n        var SUBSEPARATOR = \":\";\n        function escape(key) {\n          var escapeRegex = /[=:]/g;\n          var escaperLookup = {\n            \"=\": \"=0\",\n            \":\": \"=2\"\n          };\n          var escapedString = key.replace(escapeRegex, function(match) {\n            return escaperLookup[match];\n          });\n          return \"$\" + escapedString;\n        }\n        var didWarnAboutMaps = false;\n        var userProvidedKeyEscapeRegex = /\\/+/g;\n        function escapeUserProvidedKey(text) {\n          return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n        }\n        function getElementKey(element, index) {\n          if (typeof element === \"object\" && element !== null && element.key != null) {\n            {\n              checkKeyStringCoercion(element.key);\n            }\n            return escape(\"\" + element.key);\n          }\n          return index.toString(36);\n        }\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n          var type = typeof children;\n          if (type === \"undefined\" || type === \"boolean\") {\n            children = null;\n          }\n          var invokeCallback = false;\n          if (children === null) {\n            invokeCallback = true;\n          } else {\n            switch (type) {\n              case \"string\":\n              case \"number\":\n                invokeCallback = true;\n                break;\n              case \"object\":\n                switch (children.$$typeof) {\n                  case REACT_ELEMENT_TYPE:\n                  case REACT_PORTAL_TYPE:\n                    invokeCallback = true;\n                }\n            }\n          }\n          if (invokeCallback) {\n            var _child = children;\n            var mappedChild = callback(_child);\n            var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n            if (isArray(mappedChild)) {\n              var escapedChildKey = \"\";\n              if (childKey != null) {\n                escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n              }\n              mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n                return c;\n              });\n            } else if (mappedChild != null) {\n              if (isValidElement(mappedChild)) {\n                {\n                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                    checkKeyStringCoercion(mappedChild.key);\n                  }\n                }\n                mappedChild = cloneAndReplaceKey(\n                  mappedChild,\n                  escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(\"\" + mappedChild.key) + \"/\" : \"\") + childKey\n                );\n              }\n              array.push(mappedChild);\n            }\n            return 1;\n          }\n          var child;\n          var nextName;\n          var subtreeCount = 0;\n          var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              child = children[i];\n              nextName = nextNamePrefix + getElementKey(child, i);\n              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n            }\n          } else {\n            var iteratorFn = getIteratorFn(children);\n            if (typeof iteratorFn === \"function\") {\n              var iterableChildren = children;\n              {\n                if (iteratorFn === iterableChildren.entries) {\n                  if (!didWarnAboutMaps) {\n                    warn(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\");\n                  }\n                  didWarnAboutMaps = true;\n                }\n              }\n              var iterator = iteratorFn.call(iterableChildren);\n              var step;\n              var ii = 0;\n              while (!(step = iterator.next()).done) {\n                child = step.value;\n                nextName = nextNamePrefix + getElementKey(child, ii++);\n                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n              }\n            } else if (type === \"object\") {\n              var childrenString = String(children);\n              throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). If you meant to render a collection of children, use an array instead.\");\n            }\n          }\n          return subtreeCount;\n        }\n        function mapChildren(children, func, context) {\n          if (children == null) {\n            return children;\n          }\n          var result = [];\n          var count = 0;\n          mapIntoArray(children, result, \"\", \"\", function(child) {\n            return func.call(context, child, count++);\n          });\n          return result;\n        }\n        function countChildren(children) {\n          var n = 0;\n          mapChildren(children, function() {\n            n++;\n          });\n          return n;\n        }\n        function forEachChildren(children, forEachFunc, forEachContext) {\n          mapChildren(children, function() {\n            forEachFunc.apply(this, arguments);\n          }, forEachContext);\n        }\n        function toArray(children) {\n          return mapChildren(children, function(child) {\n            return child;\n          }) || [];\n        }\n        function onlyChild(children) {\n          if (!isValidElement(children)) {\n            throw new Error(\"React.Children.only expected to receive a single React element child.\");\n          }\n          return children;\n        }\n        function createContext(defaultValue) {\n          var context = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            _currentValue: defaultValue,\n            _currentValue2: defaultValue,\n            _threadCount: 0,\n            Provider: null,\n            Consumer: null,\n            _defaultValue: null,\n            _globalName: null\n          };\n          context.Provider = {\n            $$typeof: REACT_PROVIDER_TYPE,\n            _context: context\n          };\n          var hasWarnedAboutUsingNestedContextConsumers = false;\n          var hasWarnedAboutUsingConsumerProvider = false;\n          var hasWarnedAboutDisplayNameOnConsumer = false;\n          {\n            var Consumer = {\n              $$typeof: REACT_CONTEXT_TYPE,\n              _context: context\n            };\n            Object.defineProperties(Consumer, {\n              Provider: {\n                get: function() {\n                  if (!hasWarnedAboutUsingConsumerProvider) {\n                    hasWarnedAboutUsingConsumerProvider = true;\n                    error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?\");\n                  }\n                  return context.Provider;\n                },\n                set: function(_Provider) {\n                  context.Provider = _Provider;\n                }\n              },\n              _currentValue: {\n                get: function() {\n                  return context._currentValue;\n                },\n                set: function(_currentValue) {\n                  context._currentValue = _currentValue;\n                }\n              },\n              _currentValue2: {\n                get: function() {\n                  return context._currentValue2;\n                },\n                set: function(_currentValue2) {\n                  context._currentValue2 = _currentValue2;\n                }\n              },\n              _threadCount: {\n                get: function() {\n                  return context._threadCount;\n                },\n                set: function(_threadCount) {\n                  context._threadCount = _threadCount;\n                }\n              },\n              Consumer: {\n                get: function() {\n                  if (!hasWarnedAboutUsingNestedContextConsumers) {\n                    hasWarnedAboutUsingNestedContextConsumers = true;\n                    error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\");\n                  }\n                  return context.Consumer;\n                }\n              },\n              displayName: {\n                get: function() {\n                  return context.displayName;\n                },\n                set: function(displayName) {\n                  if (!hasWarnedAboutDisplayNameOnConsumer) {\n                    warn(\"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                    hasWarnedAboutDisplayNameOnConsumer = true;\n                  }\n                }\n              }\n            });\n            context.Consumer = Consumer;\n          }\n          {\n            context._currentRenderer = null;\n            context._currentRenderer2 = null;\n          }\n          return context;\n        }\n        var Uninitialized = -1;\n        var Pending = 0;\n        var Resolved = 1;\n        var Rejected = 2;\n        function lazyInitializer(payload) {\n          if (payload._status === Uninitialized) {\n            var ctor = payload._result;\n            var thenable = ctor();\n            thenable.then(function(moduleObject2) {\n              if (payload._status === Pending || payload._status === Uninitialized) {\n                var resolved = payload;\n                resolved._status = Resolved;\n                resolved._result = moduleObject2;\n              }\n            }, function(error2) {\n              if (payload._status === Pending || payload._status === Uninitialized) {\n                var rejected = payload;\n                rejected._status = Rejected;\n                rejected._result = error2;\n              }\n            });\n            if (payload._status === Uninitialized) {\n              var pending = payload;\n              pending._status = Pending;\n              pending._result = thenable;\n            }\n          }\n          if (payload._status === Resolved) {\n            var moduleObject = payload._result;\n            {\n              if (moduleObject === void 0) {\n                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\", moduleObject);\n              }\n            }\n            {\n              if (!(\"default\" in moduleObject)) {\n                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\", moduleObject);\n              }\n            }\n            return moduleObject.default;\n          } else {\n            throw payload._result;\n          }\n        }\n        function lazy(ctor) {\n          var payload = {\n            _status: Uninitialized,\n            _result: ctor\n          };\n          var lazyType = {\n            $$typeof: REACT_LAZY_TYPE,\n            _payload: payload,\n            _init: lazyInitializer\n          };\n          {\n            var defaultProps;\n            var propTypes;\n            Object.defineProperties(lazyType, {\n              defaultProps: {\n                configurable: true,\n                get: function() {\n                  return defaultProps;\n                },\n                set: function(newDefaultProps) {\n                  error(\"React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\n                  defaultProps = newDefaultProps;\n                  Object.defineProperty(lazyType, \"defaultProps\", {\n                    enumerable: true\n                  });\n                }\n              },\n              propTypes: {\n                configurable: true,\n                get: function() {\n                  return propTypes;\n                },\n                set: function(newPropTypes) {\n                  error(\"React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\n                  propTypes = newPropTypes;\n                  Object.defineProperty(lazyType, \"propTypes\", {\n                    enumerable: true\n                  });\n                }\n              }\n            });\n          }\n          return lazyType;\n        }\n        function forwardRef(render) {\n          {\n            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n              error(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\");\n            } else if (typeof render !== \"function\") {\n              error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n            } else {\n              if (render.length !== 0 && render.length !== 2) {\n                error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n              }\n            }\n            if (render != null) {\n              if (render.defaultProps != null || render.propTypes != null) {\n                error(\"forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?\");\n              }\n            }\n          }\n          var elementType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render\n          };\n          {\n            var ownName;\n            Object.defineProperty(elementType, \"displayName\", {\n              enumerable: false,\n              configurable: true,\n              get: function() {\n                return ownName;\n              },\n              set: function(name) {\n                ownName = name;\n                if (!render.name && !render.displayName) {\n                  render.displayName = name;\n                }\n              }\n            });\n          }\n          return elementType;\n        }\n        var REACT_MODULE_REFERENCE;\n        {\n          REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function memo(type, compare) {\n          {\n            if (!isValidElementType(type)) {\n              error(\"memo: The first argument must be a component. Instead received: %s\", type === null ? \"null\" : typeof type);\n            }\n          }\n          var elementType = {\n            $$typeof: REACT_MEMO_TYPE,\n            type,\n            compare: compare === void 0 ? null : compare\n          };\n          {\n            var ownName;\n            Object.defineProperty(elementType, \"displayName\", {\n              enumerable: false,\n              configurable: true,\n              get: function() {\n                return ownName;\n              },\n              set: function(name) {\n                ownName = name;\n                if (!type.name && !type.displayName) {\n                  type.displayName = name;\n                }\n              }\n            });\n          }\n          return elementType;\n        }\n        function resolveDispatcher() {\n          var dispatcher = ReactCurrentDispatcher.current;\n          {\n            if (dispatcher === null) {\n              error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n          }\n          return dispatcher;\n        }\n        function useContext(Context) {\n          var dispatcher = resolveDispatcher();\n          {\n            if (Context._context !== void 0) {\n              var realContext = Context._context;\n              if (realContext.Consumer === Context) {\n                error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?\");\n              } else if (realContext.Provider === Context) {\n                error(\"Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?\");\n              }\n            }\n          }\n          return dispatcher.useContext(Context);\n        }\n        function useState(initialState) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useState(initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useReducer(reducer, initialArg, init);\n        }\n        function useRef(initialValue) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useRef(initialValue);\n        }\n        function useEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useEffect(create, deps);\n        }\n        function useInsertionEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useInsertionEffect(create, deps);\n        }\n        function useLayoutEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useLayoutEffect(create, deps);\n        }\n        function useCallback(callback, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useCallback(callback, deps);\n        }\n        function useMemo(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useMemo(create, deps);\n        }\n        function useImperativeHandle(ref, create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useImperativeHandle(ref, create, deps);\n        }\n        function useDebugValue(value, formatterFn) {\n          {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useDebugValue(value, formatterFn);\n          }\n        }\n        function useTransition() {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useTransition();\n        }\n        function useDeferredValue(value) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useDeferredValue(value);\n        }\n        function useId() {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useId();\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        }\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher$1.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component2) {\n          var prototype = Component2.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        function setCurrentlyValidatingElement$1(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              setExtraStackFrame(stack);\n            } else {\n              setExtraStackFrame(null);\n            }\n          }\n        }\n        var propTypesMisspellWarningShown;\n        {\n          propTypesMisspellWarningShown = false;\n        }\n        function getDeclarationErrorAddendum() {\n          if (ReactCurrentOwner.current) {\n            var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n            if (name) {\n              return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n            }\n          }\n          return \"\";\n        }\n        function getSourceInfoErrorAddendum(source) {\n          if (source !== void 0) {\n            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n            var lineNumber = source.lineNumber;\n            return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n          }\n          return \"\";\n        }\n        function getSourceInfoErrorAddendumForProps(elementProps) {\n          if (elementProps !== null && elementProps !== void 0) {\n            return getSourceInfoErrorAddendum(elementProps.__source);\n          }\n          return \"\";\n        }\n        var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n          var info = getDeclarationErrorAddendum();\n          if (!info) {\n            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n            if (parentName) {\n              info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n            }\n          }\n          return info;\n        }\n        function validateExplicitKey(element, parentType) {\n          if (!element._store || element._store.validated || element.key != null) {\n            return;\n          }\n          element._store.validated = true;\n          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n            return;\n          }\n          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n          var childOwner = \"\";\n          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n            childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n          }\n          {\n            setCurrentlyValidatingElement$1(element);\n            error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n        function validateChildKeys(node, parentType) {\n          if (typeof node !== \"object\") {\n            return;\n          }\n          if (isArray(node)) {\n            for (var i = 0; i < node.length; i++) {\n              var child = node[i];\n              if (isValidElement(child)) {\n                validateExplicitKey(child, parentType);\n              }\n            }\n          } else if (isValidElement(node)) {\n            if (node._store) {\n              node._store.validated = true;\n            }\n          } else if (node) {\n            var iteratorFn = getIteratorFn(node);\n            if (typeof iteratorFn === \"function\") {\n              if (iteratorFn !== node.entries) {\n                var iterator = iteratorFn.call(node);\n                var step;\n                while (!(step = iterator.next()).done) {\n                  if (isValidElement(step.value)) {\n                    validateExplicitKey(step.value, parentType);\n                  }\n                }\n              }\n            }\n          }\n        }\n        function validatePropTypes(element) {\n          {\n            var type = element.type;\n            if (type === null || type === void 0 || typeof type === \"string\") {\n              return;\n            }\n            var propTypes;\n            if (typeof type === \"function\") {\n              propTypes = type.propTypes;\n            } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {\n              propTypes = type.propTypes;\n            } else {\n              return;\n            }\n            if (propTypes) {\n              var name = getComponentNameFromType(type);\n              checkPropTypes(propTypes, element.props, \"prop\", name, element);\n            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n              propTypesMisspellWarningShown = true;\n              var _name = getComponentNameFromType(type);\n              error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n            }\n            if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n            }\n          }\n        }\n        function validateFragmentProps(fragment) {\n          {\n            var keys = Object.keys(fragment.props);\n            for (var i = 0; i < keys.length; i++) {\n              var key = keys[i];\n              if (key !== \"children\" && key !== \"key\") {\n                setCurrentlyValidatingElement$1(fragment);\n                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n                setCurrentlyValidatingElement$1(null);\n                break;\n              }\n            }\n            if (fragment.ref !== null) {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n              setCurrentlyValidatingElement$1(null);\n            }\n          }\n        }\n        function createElementWithValidation(type, props, children) {\n          var validType = isValidElementType(type);\n          if (!validType) {\n            var info = \"\";\n            if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n              info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n            }\n            var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n            if (sourceInfo) {\n              info += sourceInfo;\n            } else {\n              info += getDeclarationErrorAddendum();\n            }\n            var typeString;\n            if (type === null) {\n              typeString = \"null\";\n            } else if (isArray(type)) {\n              typeString = \"array\";\n            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n              typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n              info = \" Did you accidentally export a JSX literal instead of a component?\";\n            } else {\n              typeString = typeof type;\n            }\n            {\n              error(\"React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n            }\n          }\n          var element = createElement.apply(this, arguments);\n          if (element == null) {\n            return element;\n          }\n          if (validType) {\n            for (var i = 2; i < arguments.length; i++) {\n              validateChildKeys(arguments[i], type);\n            }\n          }\n          if (type === REACT_FRAGMENT_TYPE) {\n            validateFragmentProps(element);\n          } else {\n            validatePropTypes(element);\n          }\n          return element;\n        }\n        var didWarnAboutDeprecatedCreateFactory = false;\n        function createFactoryWithValidation(type) {\n          var validatedFactory = createElementWithValidation.bind(null, type);\n          validatedFactory.type = type;\n          {\n            if (!didWarnAboutDeprecatedCreateFactory) {\n              didWarnAboutDeprecatedCreateFactory = true;\n              warn(\"React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\");\n            }\n            Object.defineProperty(validatedFactory, \"type\", {\n              enumerable: false,\n              get: function() {\n                warn(\"Factory.type is deprecated. Access the class directly before passing it to createFactory.\");\n                Object.defineProperty(this, \"type\", {\n                  value: type\n                });\n                return type;\n              }\n            });\n          }\n          return validatedFactory;\n        }\n        function cloneElementWithValidation(element, props, children) {\n          var newElement = cloneElement.apply(this, arguments);\n          for (var i = 2; i < arguments.length; i++) {\n            validateChildKeys(arguments[i], newElement.type);\n          }\n          validatePropTypes(newElement);\n          return newElement;\n        }\n        function startTransition(scope, options) {\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = {};\n          var currentTransition = ReactCurrentBatchConfig.transition;\n          {\n            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();\n          }\n          try {\n            scope();\n          } finally {\n            ReactCurrentBatchConfig.transition = prevTransition;\n            {\n              if (prevTransition === null && currentTransition._updatedFibers) {\n                var updatedFibersCount = currentTransition._updatedFibers.size;\n                if (updatedFibersCount > 10) {\n                  warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\");\n                }\n                currentTransition._updatedFibers.clear();\n              }\n            }\n          }\n        }\n        var didWarnAboutMessageChannel = false;\n        var enqueueTaskImpl = null;\n        function enqueueTask(task) {\n          if (enqueueTaskImpl === null) {\n            try {\n              var requireString = (\"require\" + Math.random()).slice(0, 7);\n              var nodeRequire = module && module[requireString];\n              enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\n            } catch (_err) {\n              enqueueTaskImpl = function(callback) {\n                {\n                  if (didWarnAboutMessageChannel === false) {\n                    didWarnAboutMessageChannel = true;\n                    if (typeof MessageChannel === \"undefined\") {\n                      error(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\");\n                    }\n                  }\n                }\n                var channel = new MessageChannel();\n                channel.port1.onmessage = callback;\n                channel.port2.postMessage(void 0);\n              };\n            }\n          }\n          return enqueueTaskImpl(task);\n        }\n        var actScopeDepth = 0;\n        var didWarnNoAwaitAct = false;\n        function act(callback) {\n          {\n            var prevActScopeDepth = actScopeDepth;\n            actScopeDepth++;\n            if (ReactCurrentActQueue.current === null) {\n              ReactCurrentActQueue.current = [];\n            }\n            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n            var result;\n            try {\n              ReactCurrentActQueue.isBatchingLegacy = true;\n              result = callback();\n              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n                var queue = ReactCurrentActQueue.current;\n                if (queue !== null) {\n                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n                  flushActQueue(queue);\n                }\n              }\n            } catch (error2) {\n              popActScope(prevActScopeDepth);\n              throw error2;\n            } finally {\n              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n            }\n            if (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\n              var thenableResult = result;\n              var wasAwaited = false;\n              var thenable = {\n                then: function(resolve, reject) {\n                  wasAwaited = true;\n                  thenableResult.then(function(returnValue2) {\n                    popActScope(prevActScopeDepth);\n                    if (actScopeDepth === 0) {\n                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);\n                    } else {\n                      resolve(returnValue2);\n                    }\n                  }, function(error2) {\n                    popActScope(prevActScopeDepth);\n                    reject(error2);\n                  });\n                }\n              };\n              {\n                if (!didWarnNoAwaitAct && typeof Promise !== \"undefined\") {\n                  Promise.resolve().then(function() {\n                  }).then(function() {\n                    if (!wasAwaited) {\n                      didWarnNoAwaitAct = true;\n                      error(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\");\n                    }\n                  });\n                }\n              }\n              return thenable;\n            } else {\n              var returnValue = result;\n              popActScope(prevActScopeDepth);\n              if (actScopeDepth === 0) {\n                var _queue = ReactCurrentActQueue.current;\n                if (_queue !== null) {\n                  flushActQueue(_queue);\n                  ReactCurrentActQueue.current = null;\n                }\n                var _thenable = {\n                  then: function(resolve, reject) {\n                    if (ReactCurrentActQueue.current === null) {\n                      ReactCurrentActQueue.current = [];\n                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                    } else {\n                      resolve(returnValue);\n                    }\n                  }\n                };\n                return _thenable;\n              } else {\n                var _thenable2 = {\n                  then: function(resolve, reject) {\n                    resolve(returnValue);\n                  }\n                };\n                return _thenable2;\n              }\n            }\n          }\n        }\n        function popActScope(prevActScopeDepth) {\n          {\n            if (prevActScopeDepth !== actScopeDepth - 1) {\n              error(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \");\n            }\n            actScopeDepth = prevActScopeDepth;\n          }\n        }\n        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n          {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              try {\n                flushActQueue(queue);\n                enqueueTask(function() {\n                  if (queue.length === 0) {\n                    ReactCurrentActQueue.current = null;\n                    resolve(returnValue);\n                  } else {\n                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                  }\n                });\n              } catch (error2) {\n                reject(error2);\n              }\n            } else {\n              resolve(returnValue);\n            }\n          }\n        }\n        var isFlushing = false;\n        function flushActQueue(queue) {\n          {\n            if (!isFlushing) {\n              isFlushing = true;\n              var i = 0;\n              try {\n                for (; i < queue.length; i++) {\n                  var callback = queue[i];\n                  do {\n                    callback = callback(true);\n                  } while (callback !== null);\n                }\n                queue.length = 0;\n              } catch (error2) {\n                queue = queue.slice(i + 1);\n                throw error2;\n              } finally {\n                isFlushing = false;\n              }\n            }\n          }\n        }\n        var createElement$1 = createElementWithValidation;\n        var cloneElement$1 = cloneElementWithValidation;\n        var createFactory = createFactoryWithValidation;\n        var Children = {\n          map: mapChildren,\n          forEach: forEachChildren,\n          count: countChildren,\n          toArray,\n          only: onlyChild\n        };\n        exports.Children = Children;\n        exports.Component = Component;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.Profiler = REACT_PROFILER_TYPE;\n        exports.PureComponent = PureComponent;\n        exports.StrictMode = REACT_STRICT_MODE_TYPE;\n        exports.Suspense = REACT_SUSPENSE_TYPE;\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n        exports.cloneElement = cloneElement$1;\n        exports.createContext = createContext;\n        exports.createElement = createElement$1;\n        exports.createFactory = createFactory;\n        exports.createRef = createRef;\n        exports.forwardRef = forwardRef;\n        exports.isValidElement = isValidElement;\n        exports.lazy = lazy;\n        exports.memo = memo;\n        exports.startTransition = startTransition;\n        exports.unstable_act = act;\n        exports.useCallback = useCallback;\n        exports.useContext = useContext;\n        exports.useDebugValue = useDebugValue;\n        exports.useDeferredValue = useDeferredValue;\n        exports.useEffect = useEffect;\n        exports.useId = useId;\n        exports.useImperativeHandle = useImperativeHandle;\n        exports.useInsertionEffect = useInsertionEffect;\n        exports.useLayoutEffect = useLayoutEffect;\n        exports.useMemo = useMemo;\n        exports.useReducer = useReducer;\n        exports.useRef = useRef;\n        exports.useState = useState;\n        exports.useSyncExternalStore = useSyncExternalStore;\n        exports.useTransition = useTransition;\n        exports.version = ReactVersion;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// ../../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js\nvar require_react = (0,_chunk_UYSIEMEK_mjs__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({\n  \"../../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js\"(exports, module) {\n    \"use strict\";\n    if (false) {} else {\n      module.exports = require_react_development();\n    }\n  }\n});\n\n\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstMkdaUEZXVUIubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRThCOztBQUU5QjtBQUNBLG1DQUFtQywrREFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0EscUlBQXFJLGtDQUFrQztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5Qix5QkFBeUI7QUFDakU7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsZ0NBQWdDLCtEQUFVO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGFBQWE7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGVBQWU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0TUFBNE07QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNklBQTZJLHlDQUF5QztBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsaUJBQWlCO0FBQ2pCLCtCQUErQjtBQUMvQjtBQUNBLGlCQUFpQjtBQUNqQiwrQkFBK0I7QUFDL0I7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQix5Q0FBeUM7QUFDekM7QUFDQSxpQkFBaUI7QUFDakIsbUNBQW1DO0FBQ25DO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsOE5BQThOO0FBQzlOO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0JBQW9CLCtEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBSUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtc2V0dXAvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstMkdaUEZXVUIubWpzPzA2YjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19jb21tb25KU1xufSBmcm9tIFwiLi9jaHVuay1VWVNJRU1FSy5tanNcIjtcblxuLy8gLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG52YXIgcmVxdWlyZV9yZWFjdF9wcm9kdWN0aW9uX21pbiA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpO1xuICAgIHZhciBuID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbiAgICB2YXIgcCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgICB2YXIgcSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbiAgICB2YXIgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICB2YXIgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xuICAgIHZhciB2ID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xuICAgIHZhciB3ID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xuICAgIHZhciB4ID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG4gICAgdmFyIHkgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbiAgICB2YXIgeiA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICBmdW5jdGlvbiBBKGEpIHtcbiAgICAgIGlmIChudWxsID09PSBhIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBhKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGEgPSB6ICYmIGFbel0gfHwgYVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYSA/IGEgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgQiA9IHsgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIH0sIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIH0sIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgfSB9O1xuICAgIHZhciBDID0gT2JqZWN0LmFzc2lnbjtcbiAgICB2YXIgRCA9IHt9O1xuICAgIGZ1bmN0aW9uIEUoYSwgYiwgZSkge1xuICAgICAgdGhpcy5wcm9wcyA9IGE7XG4gICAgICB0aGlzLmNvbnRleHQgPSBiO1xuICAgICAgdGhpcy5yZWZzID0gRDtcbiAgICAgIHRoaXMudXBkYXRlciA9IGUgfHwgQjtcbiAgICB9XG4gICAgRS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuICAgIEUucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBhICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGEgJiYgbnVsbCAhPSBhKVxuICAgICAgICB0aHJvdyBFcnJvcihcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiKTtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgYSwgYiwgXCJzZXRTdGF0ZVwiKTtcbiAgICB9O1xuICAgIEUucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oYSkge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBhLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gRigpIHtcbiAgICB9XG4gICAgRi5wcm90b3R5cGUgPSBFLnByb3RvdHlwZTtcbiAgICBmdW5jdGlvbiBHKGEsIGIsIGUpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBhO1xuICAgICAgdGhpcy5jb250ZXh0ID0gYjtcbiAgICAgIHRoaXMucmVmcyA9IEQ7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSBlIHx8IEI7XG4gICAgfVxuICAgIHZhciBIID0gRy5wcm90b3R5cGUgPSBuZXcgRigpO1xuICAgIEguY29uc3RydWN0b3IgPSBHO1xuICAgIEMoSCwgRS5wcm90b3R5cGUpO1xuICAgIEguaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuICAgIHZhciBJID0gQXJyYXkuaXNBcnJheTtcbiAgICB2YXIgSiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIEsgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgICB2YXIgTCA9IHsga2V5OiB0cnVlLCByZWY6IHRydWUsIF9fc2VsZjogdHJ1ZSwgX19zb3VyY2U6IHRydWUgfTtcbiAgICBmdW5jdGlvbiBNKGEsIGIsIGUpIHtcbiAgICAgIHZhciBkLCBjID0ge30sIGsgPSBudWxsLCBoID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9IGIpXG4gICAgICAgIGZvciAoZCBpbiB2b2lkIDAgIT09IGIucmVmICYmIChoID0gYi5yZWYpLCB2b2lkIDAgIT09IGIua2V5ICYmIChrID0gXCJcIiArIGIua2V5KSwgYilcbiAgICAgICAgICBKLmNhbGwoYiwgZCkgJiYgIUwuaGFzT3duUHJvcGVydHkoZCkgJiYgKGNbZF0gPSBiW2RdKTtcbiAgICAgIHZhciBnID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoMSA9PT0gZylcbiAgICAgICAgYy5jaGlsZHJlbiA9IGU7XG4gICAgICBlbHNlIGlmICgxIDwgZykge1xuICAgICAgICBmb3IgKHZhciBmID0gQXJyYXkoZyksIG0gPSAwOyBtIDwgZzsgbSsrKVxuICAgICAgICAgIGZbbV0gPSBhcmd1bWVudHNbbSArIDJdO1xuICAgICAgICBjLmNoaWxkcmVuID0gZjtcbiAgICAgIH1cbiAgICAgIGlmIChhICYmIGEuZGVmYXVsdFByb3BzKVxuICAgICAgICBmb3IgKGQgaW4gZyA9IGEuZGVmYXVsdFByb3BzLCBnKVxuICAgICAgICAgIHZvaWQgMCA9PT0gY1tkXSAmJiAoY1tkXSA9IGdbZF0pO1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IGwsIHR5cGU6IGEsIGtleTogaywgcmVmOiBoLCBwcm9wczogYywgX293bmVyOiBLLmN1cnJlbnQgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTihhLCBiKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogbCwgdHlwZTogYS50eXBlLCBrZXk6IGIsIHJlZjogYS5yZWYsIHByb3BzOiBhLnByb3BzLCBfb3duZXI6IGEuX293bmVyIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIE8oYSkge1xuICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT09IHR5cGVvZiBhICYmIG51bGwgIT09IGEgJiYgYS4kJHR5cGVvZiA9PT0gbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlKGEpIHtcbiAgICAgIHZhciBiID0geyBcIj1cIjogXCI9MFwiLCBcIjpcIjogXCI9MlwiIH07XG4gICAgICByZXR1cm4gXCIkXCIgKyBhLnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24oYTIpIHtcbiAgICAgICAgcmV0dXJuIGJbYTJdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBQID0gL1xcLysvZztcbiAgICBmdW5jdGlvbiBRKGEsIGIpIHtcbiAgICAgIHJldHVybiBcIm9iamVjdFwiID09PSB0eXBlb2YgYSAmJiBudWxsICE9PSBhICYmIG51bGwgIT0gYS5rZXkgPyBlc2NhcGUoXCJcIiArIGEua2V5KSA6IGIudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSKGEsIGIsIGUsIGQsIGMpIHtcbiAgICAgIHZhciBrID0gdHlwZW9mIGE7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gayB8fCBcImJvb2xlYW5cIiA9PT0gaylcbiAgICAgICAgYSA9IG51bGw7XG4gICAgICB2YXIgaCA9IGZhbHNlO1xuICAgICAgaWYgKG51bGwgPT09IGEpXG4gICAgICAgIGggPSB0cnVlO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgaCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBzd2l0Y2ggKGEuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICAgICAgaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmIChoKVxuICAgICAgICByZXR1cm4gaCA9IGEsIGMgPSBjKGgpLCBhID0gXCJcIiA9PT0gZCA/IFwiLlwiICsgUShoLCAwKSA6IGQsIEkoYykgPyAoZSA9IFwiXCIsIG51bGwgIT0gYSAmJiAoZSA9IGEucmVwbGFjZShQLCBcIiQmL1wiKSArIFwiL1wiKSwgUihjLCBiLCBlLCBcIlwiLCBmdW5jdGlvbihhMikge1xuICAgICAgICAgIHJldHVybiBhMjtcbiAgICAgICAgfSkpIDogbnVsbCAhPSBjICYmIChPKGMpICYmIChjID0gTihjLCBlICsgKCFjLmtleSB8fCBoICYmIGgua2V5ID09PSBjLmtleSA/IFwiXCIgOiAoXCJcIiArIGMua2V5KS5yZXBsYWNlKFAsIFwiJCYvXCIpICsgXCIvXCIpICsgYSkpLCBiLnB1c2goYykpLCAxO1xuICAgICAgaCA9IDA7XG4gICAgICBkID0gXCJcIiA9PT0gZCA/IFwiLlwiIDogZCArIFwiOlwiO1xuICAgICAgaWYgKEkoYSkpXG4gICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgYS5sZW5ndGg7IGcrKykge1xuICAgICAgICAgIGsgPSBhW2ddO1xuICAgICAgICAgIHZhciBmID0gZCArIFEoaywgZyk7XG4gICAgICAgICAgaCArPSBSKGssIGIsIGUsIGYsIGMpO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChmID0gQShhKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZilcbiAgICAgICAgZm9yIChhID0gZi5jYWxsKGEpLCBnID0gMDsgIShrID0gYS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICBrID0gay52YWx1ZSwgZiA9IGQgKyBRKGssIGcrKyksIGggKz0gUihrLCBiLCBlLCBmLCBjKTtcbiAgICAgIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IGspXG4gICAgICAgIHRocm93IGIgPSBTdHJpbmcoYSksIEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBiID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKSArIFwifVwiIDogYikgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIik7XG4gICAgICByZXR1cm4gaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUyhhLCBiLCBlKSB7XG4gICAgICBpZiAobnVsbCA9PSBhKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHZhciBkID0gW10sIGMgPSAwO1xuICAgICAgUihhLCBkLCBcIlwiLCBcIlwiLCBmdW5jdGlvbihhMikge1xuICAgICAgICByZXR1cm4gYi5jYWxsKGUsIGEyLCBjKyspO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVChhKSB7XG4gICAgICBpZiAoLTEgPT09IGEuX3N0YXR1cykge1xuICAgICAgICB2YXIgYiA9IGEuX3Jlc3VsdDtcbiAgICAgICAgYiA9IGIoKTtcbiAgICAgICAgYi50aGVuKGZ1bmN0aW9uKGIyKSB7XG4gICAgICAgICAgaWYgKDAgPT09IGEuX3N0YXR1cyB8fCAtMSA9PT0gYS5fc3RhdHVzKVxuICAgICAgICAgICAgYS5fc3RhdHVzID0gMSwgYS5fcmVzdWx0ID0gYjI7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGIyKSB7XG4gICAgICAgICAgaWYgKDAgPT09IGEuX3N0YXR1cyB8fCAtMSA9PT0gYS5fc3RhdHVzKVxuICAgICAgICAgICAgYS5fc3RhdHVzID0gMiwgYS5fcmVzdWx0ID0gYjI7XG4gICAgICAgIH0pO1xuICAgICAgICAtMSA9PT0gYS5fc3RhdHVzICYmIChhLl9zdGF0dXMgPSAwLCBhLl9yZXN1bHQgPSBiKTtcbiAgICAgIH1cbiAgICAgIGlmICgxID09PSBhLl9zdGF0dXMpXG4gICAgICAgIHJldHVybiBhLl9yZXN1bHQuZGVmYXVsdDtcbiAgICAgIHRocm93IGEuX3Jlc3VsdDtcbiAgICB9XG4gICAgdmFyIFUgPSB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgICB2YXIgViA9IHsgdHJhbnNpdGlvbjogbnVsbCB9O1xuICAgIHZhciBXID0geyBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBVLCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogViwgUmVhY3RDdXJyZW50T3duZXI6IEsgfTtcbiAgICBleHBvcnRzLkNoaWxkcmVuID0geyBtYXA6IFMsIGZvckVhY2g6IGZ1bmN0aW9uKGEsIGIsIGUpIHtcbiAgICAgIFMoYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0sIGUpO1xuICAgIH0sIGNvdW50OiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYiA9IDA7XG4gICAgICBTKGEsIGZ1bmN0aW9uKCkge1xuICAgICAgICBiKys7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiO1xuICAgIH0sIHRvQXJyYXk6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBTKGEsIGZ1bmN0aW9uKGEyKSB7XG4gICAgICAgIHJldHVybiBhMjtcbiAgICAgIH0pIHx8IFtdO1xuICAgIH0sIG9ubHk6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmICghTyhhKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIik7XG4gICAgICByZXR1cm4gYTtcbiAgICB9IH07XG4gICAgZXhwb3J0cy5Db21wb25lbnQgPSBFO1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBwO1xuICAgIGV4cG9ydHMuUHJvZmlsZXIgPSByO1xuICAgIGV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IEc7XG4gICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gcTtcbiAgICBleHBvcnRzLlN1c3BlbnNlID0gdztcbiAgICBleHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gVztcbiAgICBleHBvcnRzLmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uKGEsIGIsIGUpIHtcbiAgICAgIGlmIChudWxsID09PSBhIHx8IHZvaWQgMCA9PT0gYSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGEgKyBcIi5cIik7XG4gICAgICB2YXIgZCA9IEMoe30sIGEucHJvcHMpLCBjID0gYS5rZXksIGsgPSBhLnJlZiwgaCA9IGEuX293bmVyO1xuICAgICAgaWYgKG51bGwgIT0gYikge1xuICAgICAgICB2b2lkIDAgIT09IGIucmVmICYmIChrID0gYi5yZWYsIGggPSBLLmN1cnJlbnQpO1xuICAgICAgICB2b2lkIDAgIT09IGIua2V5ICYmIChjID0gXCJcIiArIGIua2V5KTtcbiAgICAgICAgaWYgKGEudHlwZSAmJiBhLnR5cGUuZGVmYXVsdFByb3BzKVxuICAgICAgICAgIHZhciBnID0gYS50eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgZm9yIChmIGluIGIpXG4gICAgICAgICAgSi5jYWxsKGIsIGYpICYmICFMLmhhc093blByb3BlcnR5KGYpICYmIChkW2ZdID0gdm9pZCAwID09PSBiW2ZdICYmIHZvaWQgMCAhPT0gZyA/IGdbZl0gOiBiW2ZdKTtcbiAgICAgIH1cbiAgICAgIHZhciBmID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICBpZiAoMSA9PT0gZilcbiAgICAgICAgZC5jaGlsZHJlbiA9IGU7XG4gICAgICBlbHNlIGlmICgxIDwgZikge1xuICAgICAgICBnID0gQXJyYXkoZik7XG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgZjsgbSsrKVxuICAgICAgICAgIGdbbV0gPSBhcmd1bWVudHNbbSArIDJdO1xuICAgICAgICBkLmNoaWxkcmVuID0gZztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBsLCB0eXBlOiBhLnR5cGUsIGtleTogYywgcmVmOiBrLCBwcm9wczogZCwgX293bmVyOiBoIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbihhKSB7XG4gICAgICBhID0geyAkJHR5cGVvZjogdSwgX2N1cnJlbnRWYWx1ZTogYSwgX2N1cnJlbnRWYWx1ZTI6IGEsIF90aHJlYWRDb3VudDogMCwgUHJvdmlkZXI6IG51bGwsIENvbnN1bWVyOiBudWxsLCBfZGVmYXVsdFZhbHVlOiBudWxsLCBfZ2xvYmFsTmFtZTogbnVsbCB9O1xuICAgICAgYS5Qcm92aWRlciA9IHsgJCR0eXBlb2Y6IHQsIF9jb250ZXh0OiBhIH07XG4gICAgICByZXR1cm4gYS5Db25zdW1lciA9IGE7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBNO1xuICAgIGV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBiID0gTS5iaW5kKG51bGwsIGEpO1xuICAgICAgYi50eXBlID0gYTtcbiAgICAgIHJldHVybiBiO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVSZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiB2LCByZW5kZXI6IGEgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBPO1xuICAgIGV4cG9ydHMubGF6eSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiB5LCBfcGF5bG9hZDogeyBfc3RhdHVzOiAtMSwgX3Jlc3VsdDogYSB9LCBfaW5pdDogVCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5tZW1vID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IHgsIHR5cGU6IGEsIGNvbXBhcmU6IHZvaWQgMCA9PT0gYiA/IG51bGwgOiBiIH07XG4gICAgfTtcbiAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBiID0gVi50cmFuc2l0aW9uO1xuICAgICAgVi50cmFuc2l0aW9uID0ge307XG4gICAgICB0cnkge1xuICAgICAgICBhKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBWLnRyYW5zaXRpb24gPSBiO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IEVycm9yKFwiYWN0KC4uLikgaXMgbm90IHN1cHBvcnRlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcyBvZiBSZWFjdC5cIik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUNhbGxiYWNrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIFUuY3VycmVudC51c2VDYWxsYmFjayhhLCBiKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlQ29udGV4dCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBVLmN1cnJlbnQudXNlQ29udGV4dChhKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIFUuY3VycmVudC51c2VEZWZlcnJlZFZhbHVlKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gVS5jdXJyZW50LnVzZUVmZmVjdChhLCBiKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBVLmN1cnJlbnQudXNlSWQoKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IGZ1bmN0aW9uKGEsIGIsIGUpIHtcbiAgICAgIHJldHVybiBVLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShhLCBiLCBlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIFUuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoYSwgYik7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBVLmN1cnJlbnQudXNlTGF5b3V0RWZmZWN0KGEsIGIpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIFUuY3VycmVudC51c2VNZW1vKGEsIGIpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VSZWR1Y2VyID0gZnVuY3Rpb24oYSwgYiwgZSkge1xuICAgICAgcmV0dXJuIFUuY3VycmVudC51c2VSZWR1Y2VyKGEsIGIsIGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gVS5jdXJyZW50LnVzZVJlZihhKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gVS5jdXJyZW50LnVzZVN0YXRlKGEpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uKGEsIGIsIGUpIHtcbiAgICAgIHJldHVybiBVLmN1cnJlbnQudXNlU3luY0V4dGVybmFsU3RvcmUoYSwgYiwgZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBVLmN1cnJlbnQudXNlVHJhbnNpdGlvbigpO1xuICAgIH07XG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXCIxOC4yLjBcIjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qc1xudmFyIHJlcXVpcmVfcmVhY3RfZGV2ZWxvcG1lbnQgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFJlYWN0VmVyc2lvbiA9IFwiMTguMi4wXCI7XG4gICAgICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTtcbiAgICAgICAgdmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbiAgICAgICAgdmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG4gICAgICAgIHZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpO1xuICAgICAgICB2YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICAgICAgdmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgICAgIHZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTtcbiAgICAgICAgdmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik7XG4gICAgICAgIHZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xuICAgICAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG4gICAgICAgIHZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTtcbiAgICAgICAgdmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xuICAgICAgICB2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuICAgICAgICB2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICAgICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBSZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IHtcbiAgICAgICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgICAgIGlzQmF0Y2hpbmdMZWdhY3k6IGZhbHNlLFxuICAgICAgICAgIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gICAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuICAgICAgICB2YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICAgICAgaWYgKGltcGwpIHtcbiAgICAgICAgICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB2YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFwid2FyblwiLCBmb3JtYXQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmludFdhcm5pbmcoXCJlcnJvclwiLCBmb3JtYXQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lMi5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2sgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZm9ybWF0ICs9IFwiJXNcIjtcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KFwiV2FybmluZzogXCIgKyBmb3JtYXQpO1xuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuICAgICAgICBmdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8IFwiUmVhY3RDbGFzc1wiO1xuICAgICAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuICAgICAgICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFRoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uIEluc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCBjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuXCIsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24ocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24ocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwicmVwbGFjZVN0YXRlXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbihwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwic2V0U3RhdGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbiAgICAgICAgdmFyIGVtcHR5T2JqZWN0ID0ge307XG4gICAgICAgIHtcbiAgICAgICAgICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24ocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09IFwiZnVuY3Rpb25cIiAmJiBwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIFwic2V0U3RhdGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssIFwiZm9yY2VVcGRhdGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgICAgICAgICBpc01vdW50ZWQ6IFtcImlzTW91bnRlZFwiLCBcIkluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLlwiXSxcbiAgICAgICAgICAgIHJlcGxhY2VTdGF0ZTogW1wicmVwbGFjZVN0YXRlXCIsIFwiUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS5cIl1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdhcm4oXCIlcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlc1wiLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgICAgICAgICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgICAgICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge1xuICAgICAgICB9XG4gICAgICAgIENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgICAgIGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbiAgICAgICAgcHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4gICAgICAgIGFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbiAgICAgICAgcHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgICAgICAgICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgICAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAge1xuICAgICAgICAgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZk9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5O1xuICAgICAgICBmdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXJyb3IoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgdHlwZU5hbWUodmFsdWUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09IFwiXCIgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBlcnJvcihcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRToge1xuICAgICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICB2YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gICAgICAgICAga2V5OiB0cnVlLFxuICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICBfX3NlbGY6IHRydWUsXG4gICAgICAgICAgX19zb3VyY2U6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbiAgICAgICAge1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwicmVmXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJyZWZcIikuZ2V0O1xuICAgICAgICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb25maWcua2V5ICE9PSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVycm9yKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09IFwic3RyaW5nXCIgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFRoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uIFdlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsIFwiX3NlbGZcIiwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lO1xuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgIHZhciBrZXkgPSBudWxsO1xuICAgICAgICAgIHZhciByZWYgPSBudWxsO1xuICAgICAgICAgIHZhciBzZWxmID0gbnVsbDtcbiAgICAgICAgICB2YXIgc291cmNlID0gbnVsbDtcbiAgICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAgICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAga2V5ID0gXCJcIiArIGNvbmZpZy5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdm9pZCAwID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgICAgICAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHZvaWQgMCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgICAgICAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiIDogdHlwZTtcbiAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICAgICAgICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gICAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByb3BOYW1lO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgICAgICAgIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgICAgICAgICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAgICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICAgICAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleSA9IFwiXCIgKyBjb25maWcua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB2b2lkIDAgJiYgZGVmYXVsdFByb3BzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgICAgIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgU0VQQVJBVE9SID0gXCIuXCI7XG4gICAgICAgIHZhciBTVUJTRVBBUkFUT1IgPSBcIjpcIjtcbiAgICAgICAgZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICAgICAgICAgIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gICAgICAgICAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgICAgICAgICBcIj1cIjogXCI9MFwiLFxuICAgICAgICAgICAgXCI6XCI6IFwiPTJcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gXCIkXCIgKyBlc2NhcGVkU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gICAgICAgIHZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG4gICAgICAgIGZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgXCIkJi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJvYmplY3RcIiAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlKFwiXCIgKyBlbGVtZW50LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuICAgICAgICAgIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09IFwiXCIgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9IFwiXCI7XG4gICAgICAgICAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArIFwiL1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgXCJcIiwgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWFwcGVkQ2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkoXG4gICAgICAgICAgICAgICAgICBtYXBwZWRDaGlsZCxcbiAgICAgICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoXCJcIiArIG1hcHBlZENoaWxkLmtleSkgKyBcIi9cIiA6IFwiXCIpICsgY2hpbGRLZXlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICB2YXIgbmV4dE5hbWU7XG4gICAgICAgICAgdmFyIHN1YnRyZWVDb3VudCA9IDA7XG4gICAgICAgICAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSBcIlwiID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09IFwiW29iamVjdCBPYmplY3RdXCIgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oXCIsIFwiKSArIFwifVwiIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VidHJlZUNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsIFwiXCIsIFwiXCIsIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gICAgICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9LCBmb3JFYWNoQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICB9KSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgX3RocmVhZENvdW50OiAwLFxuICAgICAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgICAgIF9kZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgICAgICAgICBfZ2xvYmFsTmFtZTogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICAgICAgICAgIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgICAgICAgICBQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkP1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBDb25zdW1lcjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkP1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiBZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBVbmluaXRpYWxpemVkID0gLTE7XG4gICAgICAgIHZhciBQZW5kaW5nID0gMDtcbiAgICAgICAgdmFyIFJlc29sdmVkID0gMTtcbiAgICAgICAgdmFyIFJlamVjdGVkID0gMjtcbiAgICAgICAgZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICAgICAgICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTtcbiAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24obW9kdWxlT2JqZWN0Mikge1xuICAgICAgICAgICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3QyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcjIpIHtcbiAgICAgICAgICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3IyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgICAgICAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVPYmplY3QgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGVycm9yKFwibGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICBjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD9cIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIShcImRlZmF1bHRcIiBpbiBtb2R1bGVPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgX3N0YXR1czogVW5pbml0aWFsaXplZCxcbiAgICAgICAgICAgIF9yZXN1bHQ6IGN0b3JcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBsYXp5VHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgICAgICAgICB2YXIgcHJvcFR5cGVzO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKFwiUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byBhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50IGlzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuXCIpO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKFwiUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byBhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50IGlzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuXCIpO1xuICAgICAgICAgICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCBcInByb3BUeXBlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYXp5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgICBlcnJvcihcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gIGNvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSBtZW1vKGZvcndhcmRSZWYoLi4uKSkuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoXCJmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuXCIsIHJlbmRlciA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHJlbmRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzXCIsIHJlbmRlci5sZW5ndGggPT09IDEgPyBcIkRpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj9cIiA6IFwiQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD9cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgICAgICAgICByZW5kZXJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvd25OYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW5kZXIubmFtZSAmJiAhcmVuZGVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcbiAgICAgICAge1xuICAgICAgICAgIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgfHwgZW5hYmxlQ2FjaGVFbGVtZW50IHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICBlcnJvcihcIm1lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1wiLCB0eXBlID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY29tcGFyZTogY29tcGFyZSA9PT0gdm9pZCAwID8gbnVsbCA6IGNvbXBhcmVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvd25OYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgb3duTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLm5hbWUgJiYgIXR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBlcnJvcihcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDtcbiAgICAgICAgICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkP1wiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGVycm9yKFwiQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlVHJhbnNpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlSWQoKSB7XG4gICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgICAgICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgICAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXNhYmxlZERlcHRoID0gMDtcbiAgICAgICAgdmFyIHByZXZMb2c7XG4gICAgICAgIHZhciBwcmV2SW5mbztcbiAgICAgICAgdmFyIHByZXZXYXJuO1xuICAgICAgICB2YXIgcHJldkVycm9yO1xuICAgICAgICB2YXIgcHJldkdyb3VwO1xuICAgICAgICB2YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xuICAgICAgICB2YXIgcHJldkdyb3VwRW5kO1xuICAgICAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHtcbiAgICAgICAgfVxuICAgICAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuICAgICAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICAgICAgICAgIGVycm9yKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gICAgICAgIHZhciBwcmVmaXg7XG4gICAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICAgICAgICBpZiAoZnJhbWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb250cm9sO1xuICAgICAgICAgIHJlZW50cnkgPSB0cnVlO1xuICAgICAgICAgIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICBjLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgICAgICAgICBjLS07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSBcIlxcblwiICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWVudHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiO1xuICAgICAgICAgIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6IFwiXCI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQyKSB7XG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudDIucHJvdG90eXBlO1xuICAgICAgICAgIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOiB7XG4gICAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgICAgICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICAgIGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcbiAgICAgICAgICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgICAgICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgbG9jYXRpb24gKyBcIiB0eXBlIGBcIiArIHR5cGVTcGVjTmFtZSArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICBlcnJvcihcIiVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIiwgY29tcG9uZW50TmFtZSB8fCBcIlJlYWN0IGNsYXNzXCIsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcbiAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgZXJyb3IoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICAgICAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcbiAgICAgICAge1xuICAgICAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgbmFtZSArIFwiYC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIik7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0IFwiICsgZmlsZU5hbWUgKyBcIjpcIiArIGxpbmVOdW1iZXIgKyBcIi5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gXCJzdHJpbmdcIiA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkT3duZXIgPSBcIlwiO1xuICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAge1xuICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcbiAgICAgICAgICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHZvaWQgMCB8fCB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcFR5cGVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgICAgICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFwicHJvcFwiLCBuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgICAgIGVycm9yKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIF9uYW1lIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09IFwiZnVuY3Rpb25cIiAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgICAgICAgICAgZXJyb3IoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiY2hpbGRyZW5cIiAmJiBrZXkgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIGtleSk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgZXJyb3IoXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7XG4gICAgICAgICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDAgfHwgdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlU3RyaW5nO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IFwibnVsbFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSBcImFycmF5XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHZvaWQgMCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCI7XG4gICAgICAgICAgICAgIGluZm8gPSBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcihcIlJlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gICAgICAgICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgICAgICAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuICAgICAgICAgICAgICB3YXJuKFwiUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCBcInR5cGVcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS5cIik7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlwZVwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICAgICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSB7fTtcbiAgICAgICAgICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2NvcGUoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZEZpYmVyc0NvdW50ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgIHdhcm4oXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gZmFsc2U7XG4gICAgICAgIHZhciBlbnF1ZXVlVGFza0ltcGwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gICAgICAgICAgaWYgKGVucXVldWVUYXNrSW1wbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoXCJyZXF1aXJlXCIgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVSZXF1aXJlID0gbW9kdWxlICYmIG1vZHVsZVtyZXF1aXJlU3RyaW5nXTtcbiAgICAgICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsIFwidGltZXJzXCIpLnNldEltbWVkaWF0ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdFNjb3BlRGVwdGggPSAwO1xuICAgICAgICB2YXIgZGlkV2Fybk5vQXdhaXRBY3QgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gYWN0KGNhbGxiYWNrKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHByZXZBY3RTY29wZURlcHRoID0gYWN0U2NvcGVEZXB0aDtcbiAgICAgICAgICAgIGFjdFNjb3BlRGVwdGgrKztcbiAgICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2SXNCYXRjaGluZ0xlZ2FjeSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmlzQmF0Y2hpbmdMZWdhY3k7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIGlmICghcHJldklzQmF0Y2hpbmdMZWdhY3kgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHByZXZJc0JhdGNoaW5nTGVnYWN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhciB0aGVuYWJsZVJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgdmFyIHdhc0F3YWl0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIHRoZW5hYmxlID0ge1xuICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgd2FzQXdhaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB0aGVuYWJsZVJlc3VsdC50aGVuKGZ1bmN0aW9uKHJldHVyblZhbHVlMikge1xuICAgICAgICAgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZTIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghZGlkV2Fybk5vQXdhaXRBY3QgJiYgdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdhc0F3YWl0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJZb3UgY2FsbGVkIGFjdChhc3luYyAoKSA9PiAuLi4pIHdpdGhvdXQgYXdhaXQuIFRoaXMgY291bGQgbGVhZCB0byB1bmV4cGVjdGVkIHRlc3RpbmcgYmVoYXZpb3VyLCBpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgc2NvcGVzLiBZb3Ugc2hvdWxkIC0gYXdhaXQgYWN0KGFzeW5jICgpID0+IC4uLik7XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9xdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKF9xdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShfcXVldWUpO1xuICAgICAgICAgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfdGhlbmFibGUgPSB7XG4gICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoZW5hYmxlMiA9IHtcbiAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhlbmFibGUyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHByZXZBY3RTY29wZURlcHRoICE9PSBhY3RTY29wZURlcHRoIC0gMSkge1xuICAgICAgICAgICAgICBlcnJvcihcIllvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0U2NvcGVEZXB0aCA9IHByZXZBY3RTY29wZURlcHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcjIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgICAgICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjI7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjcmVhdGVFbGVtZW50JDEgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb247XG4gICAgICAgIHZhciBjbG9uZUVsZW1lbnQkMSA9IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uO1xuICAgICAgICB2YXIgY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbjtcbiAgICAgICAgdmFyIENoaWxkcmVuID0ge1xuICAgICAgICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgICAgICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgICAgICAgIHRvQXJyYXksXG4gICAgICAgICAgb25seTogb25seUNoaWxkXG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbiAgICAgICAgZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgICAgICBleHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICAgICAgZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbiAgICAgICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICAgICAgZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgICAgIGV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbiAgICAgICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbiAgICAgICAgZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbiAgICAgICAgZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuICAgICAgICBleHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuICAgICAgICBleHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbiAgICAgICAgZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbiAgICAgICAgZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuICAgICAgICBleHBvcnRzLmxhenkgPSBsYXp5O1xuICAgICAgICBleHBvcnRzLm1lbW8gPSBtZW1vO1xuICAgICAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IHN0YXJ0VHJhbnNpdGlvbjtcbiAgICAgICAgZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBhY3Q7XG4gICAgICAgIGV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbiAgICAgICAgZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbiAgICAgICAgZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbiAgICAgICAgZXhwb3J0cy51c2VEZWZlcnJlZFZhbHVlID0gdXNlRGVmZXJyZWRWYWx1ZTtcbiAgICAgICAgZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG4gICAgICAgIGV4cG9ydHMudXNlSWQgPSB1c2VJZDtcbiAgICAgICAgZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbiAgICAgICAgZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG4gICAgICAgIGV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuICAgICAgICBleHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuICAgICAgICBleHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuICAgICAgICBleHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbiAgICAgICAgZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuICAgICAgICBleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG4gICAgICAgIGV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb247XG4gICAgICAgIGV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qc1xudmFyIHJlcXVpcmVfcmVhY3QgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9yZWFjdF9wcm9kdWN0aW9uX21pbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfcmVhY3RfZGV2ZWxvcG1lbnQoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5leHBvcnQge1xuICByZXF1aXJlX3JlYWN0XG59O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-2GZPFWUB.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-BSXPKUBX.mjs":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-BSXPKUBX.mjs ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterDOMProps: () => (/* binding */ filterDOMProps)\n/* harmony export */ });\n/* harmony import */ var _chunk_MDCHOOWF_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-MDCHOOWF.mjs */ \"(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-MDCHOOWF.mjs\");\n\n\n// src/filter-dom-props.ts\nvar propRe = /^(data-.*)$/;\nvar ariaRe = /^(aria-.*)$/;\nvar funcRe = /^(on[A-Z].*)$/;\nfunction filterDOMProps(props, opts = {}) {\n  let { labelable = true, enabled = true, propNames, omitPropNames, omitEventNames } = opts;\n  let filteredProps = {};\n  if (!enabled) {\n    return props;\n  }\n  for (const prop in props) {\n    if (omitPropNames == null ? void 0 : omitPropNames.has(prop)) {\n      continue;\n    }\n    if ((omitEventNames == null ? void 0 : omitEventNames.has(prop)) && funcRe.test(prop)) {\n      continue;\n    }\n    if (funcRe.test(prop) && !_chunk_MDCHOOWF_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMEventNames.has(prop)) {\n      continue;\n    }\n    if (Object.prototype.hasOwnProperty.call(props, prop) && (_chunk_MDCHOOWF_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMPropNames.has(prop) || labelable && ariaRe.test(prop) || (propNames == null ? void 0 : propNames.has(prop)) || propRe.test(prop)) || funcRe.test(prop)) {\n      filteredProps[prop] = props[prop];\n    }\n  }\n  return filteredProps;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstQlNYUEtVQlgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRzhCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxRQUFRLDZFQUE2RTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFhO0FBQzNDO0FBQ0E7QUFDQSw4REFBOEQsNkRBQVk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1zZXR1cC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dHVpLW9yZytyZWFjdC1yc2MtdXRpbHNAMi4wLjEwL25vZGVfbW9kdWxlcy9AbmV4dHVpLW9yZy9yZWFjdC1yc2MtdXRpbHMvZGlzdC9jaHVuay1CU1hQS1VCWC5tanM/MjM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBET01FdmVudE5hbWVzLFxuICBET01Qcm9wTmFtZXNcbn0gZnJvbSBcIi4vY2h1bmstTURDSE9PV0YubWpzXCI7XG5cbi8vIHNyYy9maWx0ZXItZG9tLXByb3BzLnRzXG52YXIgcHJvcFJlID0gL14oZGF0YS0uKikkLztcbnZhciBhcmlhUmUgPSAvXihhcmlhLS4qKSQvO1xudmFyIGZ1bmNSZSA9IC9eKG9uW0EtWl0uKikkLztcbmZ1bmN0aW9uIGZpbHRlckRPTVByb3BzKHByb3BzLCBvcHRzID0ge30pIHtcbiAgbGV0IHsgbGFiZWxhYmxlID0gdHJ1ZSwgZW5hYmxlZCA9IHRydWUsIHByb3BOYW1lcywgb21pdFByb3BOYW1lcywgb21pdEV2ZW50TmFtZXMgfSA9IG9wdHM7XG4gIGxldCBmaWx0ZXJlZFByb3BzID0ge307XG4gIGlmICghZW5hYmxlZCkge1xuICAgIHJldHVybiBwcm9wcztcbiAgfVxuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICBpZiAob21pdFByb3BOYW1lcyA9PSBudWxsID8gdm9pZCAwIDogb21pdFByb3BOYW1lcy5oYXMocHJvcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKG9taXRFdmVudE5hbWVzID09IG51bGwgPyB2b2lkIDAgOiBvbWl0RXZlbnROYW1lcy5oYXMocHJvcCkpICYmIGZ1bmNSZS50ZXN0KHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZ1bmNSZS50ZXN0KHByb3ApICYmICFET01FdmVudE5hbWVzLmhhcyhwcm9wKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3ApICYmIChET01Qcm9wTmFtZXMuaGFzKHByb3ApIHx8IGxhYmVsYWJsZSAmJiBhcmlhUmUudGVzdChwcm9wKSB8fCAocHJvcE5hbWVzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wTmFtZXMuaGFzKHByb3ApKSB8fCBwcm9wUmUudGVzdChwcm9wKSkgfHwgZnVuY1JlLnRlc3QocHJvcCkpIHtcbiAgICAgIGZpbHRlcmVkUHJvcHNbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cbmV4cG9ydCB7XG4gIGZpbHRlckRPTVByb3BzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-BSXPKUBX.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-MDCHOOWF.mjs":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-MDCHOOWF.mjs ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMEventNames: () => (/* binding */ DOMEventNames),\n/* harmony export */   DOMPropNames: () => (/* binding */ DOMPropNames)\n/* harmony export */ });\n// src/dom-props.ts\nvar DOMPropNames = /* @__PURE__ */ new Set([\n  \"id\",\n  \"type\",\n  \"style\",\n  \"title\",\n  \"role\",\n  \"tabIndex\",\n  \"htmlFor\",\n  \"width\",\n  \"height\",\n  \"abbr\",\n  \"accept\",\n  \"acceptCharset\",\n  \"accessKey\",\n  \"action\",\n  \"allowFullScreen\",\n  \"allowTransparency\",\n  \"alt\",\n  \"async\",\n  \"autoComplete\",\n  \"autoFocus\",\n  \"autoPlay\",\n  \"cellPadding\",\n  \"cellSpacing\",\n  \"challenge\",\n  \"charset\",\n  \"checked\",\n  \"cite\",\n  \"class\",\n  \"className\",\n  \"cols\",\n  \"colSpan\",\n  \"command\",\n  \"content\",\n  \"contentEditable\",\n  \"contextMenu\",\n  \"controls\",\n  \"coords\",\n  \"crossOrigin\",\n  \"data\",\n  \"dateTime\",\n  \"default\",\n  \"defer\",\n  \"dir\",\n  \"disabled\",\n  \"download\",\n  \"draggable\",\n  \"dropzone\",\n  \"encType\",\n  \"for\",\n  \"form\",\n  \"formAction\",\n  \"formEncType\",\n  \"formMethod\",\n  \"formNoValidate\",\n  \"formTarget\",\n  \"frameBorder\",\n  \"headers\",\n  \"hidden\",\n  \"high\",\n  \"href\",\n  \"hrefLang\",\n  \"httpEquiv\",\n  \"icon\",\n  \"inputMode\",\n  \"isMap\",\n  \"itemId\",\n  \"itemProp\",\n  \"itemRef\",\n  \"itemScope\",\n  \"itemType\",\n  \"kind\",\n  \"label\",\n  \"lang\",\n  \"list\",\n  \"loop\",\n  \"manifest\",\n  \"max\",\n  \"maxLength\",\n  \"media\",\n  \"mediaGroup\",\n  \"method\",\n  \"min\",\n  \"minLength\",\n  \"multiple\",\n  \"muted\",\n  \"name\",\n  \"noValidate\",\n  \"open\",\n  \"optimum\",\n  \"pattern\",\n  \"ping\",\n  \"placeholder\",\n  \"poster\",\n  \"preload\",\n  \"radioGroup\",\n  \"referrerPolicy\",\n  \"readOnly\",\n  \"rel\",\n  \"required\",\n  \"rows\",\n  \"rowSpan\",\n  \"sandbox\",\n  \"scope\",\n  \"scoped\",\n  \"scrolling\",\n  \"seamless\",\n  \"selected\",\n  \"shape\",\n  \"size\",\n  \"sizes\",\n  \"slot\",\n  \"sortable\",\n  \"span\",\n  \"spellCheck\",\n  \"src\",\n  \"srcDoc\",\n  \"srcSet\",\n  \"start\",\n  \"step\",\n  \"target\",\n  \"translate\",\n  \"typeMustMatch\",\n  \"useMap\",\n  \"value\",\n  \"wmode\",\n  \"wrap\"\n]);\nvar DOMEventNames = /* @__PURE__ */ new Set([\n  \"onCopy\",\n  \"onCut\",\n  \"onPaste\",\n  \"onLoad\",\n  \"onError\",\n  \"onWheel\",\n  \"onScroll\",\n  \"onCompositionEnd\",\n  \"onCompositionStart\",\n  \"onCompositionUpdate\",\n  \"onKeyDown\",\n  \"onKeyPress\",\n  \"onKeyUp\",\n  \"onFocus\",\n  \"onBlur\",\n  \"onChange\",\n  \"onInput\",\n  \"onSubmit\",\n  \"onClick\",\n  \"onContextMenu\",\n  \"onDoubleClick\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onDragEnter\",\n  \"onDragExit\",\n  \"onDragLeave\",\n  \"onDragOver\",\n  \"onDragStart\",\n  \"onDrop\",\n  \"onMouseDown\",\n  \"onMouseEnter\",\n  \"onMouseLeave\",\n  \"onMouseMove\",\n  \"onMouseOut\",\n  \"onMouseOver\",\n  \"onMouseUp\",\n  \"onPointerDown\",\n  \"onPointerEnter\",\n  \"onPointerLeave\",\n  \"onPointerUp\",\n  \"onSelect\",\n  \"onTouchCancel\",\n  \"onTouchEnd\",\n  \"onTouchMove\",\n  \"onTouchStart\",\n  \"onAnimationStart\",\n  \"onAnimationEnd\",\n  \"onAnimationIteration\",\n  \"onTransitionEnd\"\n]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstTURDSE9PV0YubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXNldHVwLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZXh0dWktb3JnK3JlYWN0LXJzYy11dGlsc0AyLjAuMTAvbm9kZV9tb2R1bGVzL0BuZXh0dWktb3JnL3JlYWN0LXJzYy11dGlscy9kaXN0L2NodW5rLU1EQ0hPT1dGLm1qcz8wNjEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kb20tcHJvcHMudHNcbnZhciBET01Qcm9wTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiaWRcIixcbiAgXCJ0eXBlXCIsXG4gIFwic3R5bGVcIixcbiAgXCJ0aXRsZVwiLFxuICBcInJvbGVcIixcbiAgXCJ0YWJJbmRleFwiLFxuICBcImh0bWxGb3JcIixcbiAgXCJ3aWR0aFwiLFxuICBcImhlaWdodFwiLFxuICBcImFiYnJcIixcbiAgXCJhY2NlcHRcIixcbiAgXCJhY2NlcHRDaGFyc2V0XCIsXG4gIFwiYWNjZXNzS2V5XCIsXG4gIFwiYWN0aW9uXCIsXG4gIFwiYWxsb3dGdWxsU2NyZWVuXCIsXG4gIFwiYWxsb3dUcmFuc3BhcmVuY3lcIixcbiAgXCJhbHRcIixcbiAgXCJhc3luY1wiLFxuICBcImF1dG9Db21wbGV0ZVwiLFxuICBcImF1dG9Gb2N1c1wiLFxuICBcImF1dG9QbGF5XCIsXG4gIFwiY2VsbFBhZGRpbmdcIixcbiAgXCJjZWxsU3BhY2luZ1wiLFxuICBcImNoYWxsZW5nZVwiLFxuICBcImNoYXJzZXRcIixcbiAgXCJjaGVja2VkXCIsXG4gIFwiY2l0ZVwiLFxuICBcImNsYXNzXCIsXG4gIFwiY2xhc3NOYW1lXCIsXG4gIFwiY29sc1wiLFxuICBcImNvbFNwYW5cIixcbiAgXCJjb21tYW5kXCIsXG4gIFwiY29udGVudFwiLFxuICBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICBcImNvbnRleHRNZW51XCIsXG4gIFwiY29udHJvbHNcIixcbiAgXCJjb29yZHNcIixcbiAgXCJjcm9zc09yaWdpblwiLFxuICBcImRhdGFcIixcbiAgXCJkYXRlVGltZVwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJkZWZlclwiLFxuICBcImRpclwiLFxuICBcImRpc2FibGVkXCIsXG4gIFwiZG93bmxvYWRcIixcbiAgXCJkcmFnZ2FibGVcIixcbiAgXCJkcm9wem9uZVwiLFxuICBcImVuY1R5cGVcIixcbiAgXCJmb3JcIixcbiAgXCJmb3JtXCIsXG4gIFwiZm9ybUFjdGlvblwiLFxuICBcImZvcm1FbmNUeXBlXCIsXG4gIFwiZm9ybU1ldGhvZFwiLFxuICBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gIFwiZm9ybVRhcmdldFwiLFxuICBcImZyYW1lQm9yZGVyXCIsXG4gIFwiaGVhZGVyc1wiLFxuICBcImhpZGRlblwiLFxuICBcImhpZ2hcIixcbiAgXCJocmVmXCIsXG4gIFwiaHJlZkxhbmdcIixcbiAgXCJodHRwRXF1aXZcIixcbiAgXCJpY29uXCIsXG4gIFwiaW5wdXRNb2RlXCIsXG4gIFwiaXNNYXBcIixcbiAgXCJpdGVtSWRcIixcbiAgXCJpdGVtUHJvcFwiLFxuICBcIml0ZW1SZWZcIixcbiAgXCJpdGVtU2NvcGVcIixcbiAgXCJpdGVtVHlwZVwiLFxuICBcImtpbmRcIixcbiAgXCJsYWJlbFwiLFxuICBcImxhbmdcIixcbiAgXCJsaXN0XCIsXG4gIFwibG9vcFwiLFxuICBcIm1hbmlmZXN0XCIsXG4gIFwibWF4XCIsXG4gIFwibWF4TGVuZ3RoXCIsXG4gIFwibWVkaWFcIixcbiAgXCJtZWRpYUdyb3VwXCIsXG4gIFwibWV0aG9kXCIsXG4gIFwibWluXCIsXG4gIFwibWluTGVuZ3RoXCIsXG4gIFwibXVsdGlwbGVcIixcbiAgXCJtdXRlZFwiLFxuICBcIm5hbWVcIixcbiAgXCJub1ZhbGlkYXRlXCIsXG4gIFwib3BlblwiLFxuICBcIm9wdGltdW1cIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwicGluZ1wiLFxuICBcInBsYWNlaG9sZGVyXCIsXG4gIFwicG9zdGVyXCIsXG4gIFwicHJlbG9hZFwiLFxuICBcInJhZGlvR3JvdXBcIixcbiAgXCJyZWZlcnJlclBvbGljeVwiLFxuICBcInJlYWRPbmx5XCIsXG4gIFwicmVsXCIsXG4gIFwicmVxdWlyZWRcIixcbiAgXCJyb3dzXCIsXG4gIFwicm93U3BhblwiLFxuICBcInNhbmRib3hcIixcbiAgXCJzY29wZVwiLFxuICBcInNjb3BlZFwiLFxuICBcInNjcm9sbGluZ1wiLFxuICBcInNlYW1sZXNzXCIsXG4gIFwic2VsZWN0ZWRcIixcbiAgXCJzaGFwZVwiLFxuICBcInNpemVcIixcbiAgXCJzaXplc1wiLFxuICBcInNsb3RcIixcbiAgXCJzb3J0YWJsZVwiLFxuICBcInNwYW5cIixcbiAgXCJzcGVsbENoZWNrXCIsXG4gIFwic3JjXCIsXG4gIFwic3JjRG9jXCIsXG4gIFwic3JjU2V0XCIsXG4gIFwic3RhcnRcIixcbiAgXCJzdGVwXCIsXG4gIFwidGFyZ2V0XCIsXG4gIFwidHJhbnNsYXRlXCIsXG4gIFwidHlwZU11c3RNYXRjaFwiLFxuICBcInVzZU1hcFwiLFxuICBcInZhbHVlXCIsXG4gIFwid21vZGVcIixcbiAgXCJ3cmFwXCJcbl0pO1xudmFyIERPTUV2ZW50TmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwib25Db3B5XCIsXG4gIFwib25DdXRcIixcbiAgXCJvblBhc3RlXCIsXG4gIFwib25Mb2FkXCIsXG4gIFwib25FcnJvclwiLFxuICBcIm9uV2hlZWxcIixcbiAgXCJvblNjcm9sbFwiLFxuICBcIm9uQ29tcG9zaXRpb25FbmRcIixcbiAgXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbiAgXCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsXG4gIFwib25LZXlEb3duXCIsXG4gIFwib25LZXlQcmVzc1wiLFxuICBcIm9uS2V5VXBcIixcbiAgXCJvbkZvY3VzXCIsXG4gIFwib25CbHVyXCIsXG4gIFwib25DaGFuZ2VcIixcbiAgXCJvbklucHV0XCIsXG4gIFwib25TdWJtaXRcIixcbiAgXCJvbkNsaWNrXCIsXG4gIFwib25Db250ZXh0TWVudVwiLFxuICBcIm9uRG91YmxlQ2xpY2tcIixcbiAgXCJvbkRyYWdcIixcbiAgXCJvbkRyYWdFbmRcIixcbiAgXCJvbkRyYWdFbnRlclwiLFxuICBcIm9uRHJhZ0V4aXRcIixcbiAgXCJvbkRyYWdMZWF2ZVwiLFxuICBcIm9uRHJhZ092ZXJcIixcbiAgXCJvbkRyYWdTdGFydFwiLFxuICBcIm9uRHJvcFwiLFxuICBcIm9uTW91c2VEb3duXCIsXG4gIFwib25Nb3VzZUVudGVyXCIsXG4gIFwib25Nb3VzZUxlYXZlXCIsXG4gIFwib25Nb3VzZU1vdmVcIixcbiAgXCJvbk1vdXNlT3V0XCIsXG4gIFwib25Nb3VzZU92ZXJcIixcbiAgXCJvbk1vdXNlVXBcIixcbiAgXCJvblBvaW50ZXJEb3duXCIsXG4gIFwib25Qb2ludGVyRW50ZXJcIixcbiAgXCJvblBvaW50ZXJMZWF2ZVwiLFxuICBcIm9uUG9pbnRlclVwXCIsXG4gIFwib25TZWxlY3RcIixcbiAgXCJvblRvdWNoQ2FuY2VsXCIsXG4gIFwib25Ub3VjaEVuZFwiLFxuICBcIm9uVG91Y2hNb3ZlXCIsXG4gIFwib25Ub3VjaFN0YXJ0XCIsXG4gIFwib25BbmltYXRpb25TdGFydFwiLFxuICBcIm9uQW5pbWF0aW9uRW5kXCIsXG4gIFwib25BbmltYXRpb25JdGVyYXRpb25cIixcbiAgXCJvblRyYW5zaXRpb25FbmRcIlxuXSk7XG5cbmV4cG9ydCB7XG4gIERPTVByb3BOYW1lcyxcbiAgRE9NRXZlbnROYW1lc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-MDCHOOWF.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-UYSIEMEK.mjs":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-UYSIEMEK.mjs ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstVVlTSUVNRUsubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBOztBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXNldHVwLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZXh0dWktb3JnK3JlYWN0LXJzYy11dGlsc0AyLjAuMTAvbm9kZV9tb2R1bGVzL0BuZXh0dWktb3JnL3JlYWN0LXJzYy11dGlscy9kaXN0L2NodW5rLVVZU0lFTUVLLm1qcz8yZDI1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG5leHBvcnQge1xuICBfX2NvbW1vbkpTLFxuICBfX3RvRVNNXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-UYSIEMEK.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-VMAPMSPF.mjs":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-VMAPMSPF.mjs ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getValidChildren: () => (/* binding */ getValidChildren),\n/* harmony export */   pickChildren: () => (/* binding */ pickChildren)\n/* harmony export */ });\n/* harmony import */ var _chunk_2GZPFWUB_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-2GZPFWUB.mjs */ \"(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-2GZPFWUB.mjs\");\n/* harmony import */ var _chunk_UYSIEMEK_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-UYSIEMEK.mjs */ \"(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-UYSIEMEK.mjs\");\n\n\n\n// src/children.ts\nvar import_react = (0,_chunk_UYSIEMEK_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_chunk_2GZPFWUB_mjs__WEBPACK_IMPORTED_MODULE_1__.require_react)());\nfunction getValidChildren(children) {\n  return import_react.Children.toArray(children).filter(\n    (child) => (0, import_react.isValidElement)(child)\n  );\n}\nvar pickChildren = (children, targetChild) => {\n  var _a;\n  let target = [];\n  const withoutTargetChildren = (_a = import_react.Children.map(children, (item) => {\n    if (!(0, import_react.isValidElement)(item))\n      return item;\n    if (item.type === targetChild) {\n      target.push(item);\n      return null;\n    }\n    return item;\n  })) == null ? void 0 : _a.filter(Boolean);\n  const targetChildren = target.length >= 0 ? target : void 0;\n  return [withoutTargetChildren, targetChildren];\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstVk1BUE1TUEYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFOEI7QUFHQTs7QUFFOUI7QUFDQSxtQkFBbUIsNERBQU8sQ0FBQyxrRUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtc2V0dXAvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5leHR1aS1vcmcrcmVhY3QtcnNjLXV0aWxzQDIuMC4xMC9ub2RlX21vZHVsZXMvQG5leHR1aS1vcmcvcmVhY3QtcnNjLXV0aWxzL2Rpc3QvY2h1bmstVk1BUE1TUEYubWpzP2NhNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgcmVxdWlyZV9yZWFjdFxufSBmcm9tIFwiLi9jaHVuay0yR1pQRldVQi5tanNcIjtcbmltcG9ydCB7XG4gIF9fdG9FU01cbn0gZnJvbSBcIi4vY2h1bmstVVlTSUVNRUsubWpzXCI7XG5cbi8vIHNyYy9jaGlsZHJlbi50c1xudmFyIGltcG9ydF9yZWFjdCA9IF9fdG9FU00ocmVxdWlyZV9yZWFjdCgpKTtcbmZ1bmN0aW9uIGdldFZhbGlkQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGltcG9ydF9yZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5maWx0ZXIoXG4gICAgKGNoaWxkKSA9PiAoMCwgaW1wb3J0X3JlYWN0LmlzVmFsaWRFbGVtZW50KShjaGlsZClcbiAgKTtcbn1cbnZhciBwaWNrQ2hpbGRyZW4gPSAoY2hpbGRyZW4sIHRhcmdldENoaWxkKSA9PiB7XG4gIHZhciBfYTtcbiAgbGV0IHRhcmdldCA9IFtdO1xuICBjb25zdCB3aXRob3V0VGFyZ2V0Q2hpbGRyZW4gPSAoX2EgPSBpbXBvcnRfcmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoaXRlbSkgPT4ge1xuICAgIGlmICghKDAsIGltcG9ydF9yZWFjdC5pc1ZhbGlkRWxlbWVudCkoaXRlbSkpXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICBpZiAoaXRlbS50eXBlID09PSB0YXJnZXRDaGlsZCkge1xuICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCB0YXJnZXRDaGlsZHJlbiA9IHRhcmdldC5sZW5ndGggPj0gMCA/IHRhcmdldCA6IHZvaWQgMDtcbiAgcmV0dXJuIFt3aXRob3V0VGFyZ2V0Q2hpbGRyZW4sIHRhcmdldENoaWxkcmVuXTtcbn07XG5cbmV4cG9ydCB7XG4gIGdldFZhbGlkQ2hpbGRyZW4sXG4gIHBpY2tDaGlsZHJlblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@nextui-org+react-rsc-utils@2.0.10/node_modules/@nextui-org/react-rsc-utils/dist/chunk-VMAPMSPF.mjs\n");

/***/ })

};
;